package lab;import java.util.HashMap;import java.util.Iterator;import java.util.Scanner;/**   A class of telephone directories.   @author Frank M. Carrano   @author Timothy M. Henry   @version 4.0*/public class TelephoneDirectory{   private DictionaryInterface<Name, String> phoneBook; // Sorted dictionary with distinct search keys   /*    * by Mark Hawes, Zack Albers, Jonathan Lee, Alain Njipwo    *     * problem 1    * reverse phone book. Works the same as the dictionary phoneBook but with the data reversed    * in order to search for a name based on phone number.    * See below for an implementation    */   private DictionaryInterface<String, Name> revPhoneBook;   /*    * problem 2    * For both the intersection and the union arrays the easiest solution would be to create a     * linked list hash table. That way when you do have collision the value is still stored in the     * table but won't break the table.     *     * Problem 3    * See ArrayDictionary.java    *     * Problem 4    * See SortedArrayDictionary.java    *     * problem 5    * You could accomplish this by concatenating a string and then hashing it.    *     * problem 6    * One option is to convert the length, width, and color to a string, then concatinate those into    * one string. Then you use that string for your hash function. The second option is to use a     * selected set of pixel location/color combinations converted into an integer as your key     * for the hash table.    *     * problem 7    * a) In order to increase the size you have to create another array of large size for the data     * to go into. Then you have to set all those values from the old array into the new array, generally    * using recursion until the old array is completely in the new one.    * b) Technically it wouldn't change the actual hash function itself, but it will add time to the     * calculation for adding additions to the table.    */   // problem 8a)   HashMap<String, Name> dictionary = new HashMap<String, Name>(1000);   // problem 8b)   public void addHash(){	   dictionary.put("Cherry", new Name("Tom", "Woodland"));	   dictionary.put("Axle", new Name("John", "Person"));	   dictionary.put("Josie", new Name("Jane", "Smith"));	   dictionary.put("Velma", new Name("Kira", "Bit"));	   System.out.println(dictionary.get("Cherry"));	   System.out.println(dictionary.get("Axle"));	   System.out.println(dictionary.get("Josie"));	   System.out.println(dictionary.get("Velma"));   }   /*    * problem 9.     * You cannot use a hashTable to implement a priority queue.Because Even if the priority of the key is raised     * there really isn't a way of finding or affecting the hashed data to become "more available to the key " searching for it.    */       public TelephoneDirectory()    {       phoneBook = new ArrayDictionary<>();      revPhoneBook = new ArrayDictionary<>();   } // end default constructor      // 19.10   /** Reads a text file of names and telephone numbers.       @param data  A text scanner for the text file of data. */   public void readFile(Scanner data)   {      while (data.hasNext())      {         String firstName   = data.next();         String lastName    = data.next();         String phoneNumber = data.next();         Name fullName = new Name(firstName, lastName);         phoneBook.add(fullName, phoneNumber);      } // end while      data.close();     } // end readFile      // 19.11   /** Gets the phone number of a given person. */   public String getPhoneNumber(Name personName)   {      return phoneBook.getValue(personName);   } // end getPhoneNumber   public String getPhoneNumber(String firstName, String lastName)   {      Name fullName = new Name(firstName, lastName);      return phoneBook.getValue(fullName);   } // end getPhoneNumber} // end TelephoneDirectory